import * as i0 from '@angular/core';
import { Injectable, ElementRef, Injector, NgModule } from '@angular/core';
import { NativeDateAdapter } from '@angular/material/core';
import { includes } from 'lodash';
import { timer, first } from 'rxjs';

const smpSep = "/";
const smpDay = "d";
const smpDayDoubled = "dd";
const smpMonth = "M";
const smpMonthDoubled = "MM";
const smpYear = "yyyy";
const smpCurrentYear = new Date().getFullYear();
const smpCentury = Math.round(smpCurrentYear / 100);
const SMP_LOCALE_IT_IT = "it-IT";
const SMP_LOCALE_EN_GB = "en-GB";
const SMP_LOCALE_EN_US = "en-US";
const SMP_FORMATS = {
    "it-IT": `${smpDayDoubled}${smpSep}${smpMonthDoubled}${smpSep}${smpYear}`,
    "en-GB": `${smpDayDoubled}${smpSep}${smpMonthDoubled}${smpSep}${smpYear}`,
    "en-US": `${smpMonth}${smpSep}${smpDay}${smpSep}${smpYear}`
};
const SMP_DATE_FORMATS_IT = {
    parse: {
        dateInput: { month: "numeric", year: "numeric", day: "numeric" }
    },
    display: {
        dateInput: SMP_FORMATS[SMP_LOCALE_IT_IT],
        monthYearLabel: `${smpMonthDoubled}${smpSep}${smpYear}`,
        dateA11yLabel: SMP_FORMATS[SMP_LOCALE_IT_IT],
        monthYearA11yLabel: `${smpMonthDoubled}${smpSep}${smpYear}`
    }
};
const SMP_DATE_FORMATS_EN_GB = {
    parse: {
        dateInput: { month: "numeric", year: "numeric", day: "numeric" }
    },
    display: {
        dateInput: SMP_FORMATS[SMP_LOCALE_EN_GB],
        monthYearLabel: `${smpMonthDoubled}${smpSep}${smpYear}`,
        dateA11yLabel: SMP_FORMATS[SMP_LOCALE_EN_GB],
        monthYearA11yLabel: `${smpMonthDoubled}${smpSep}${smpYear}`
    }
};
const SMP_DATE_FORMATS_EN_US = {
    parse: {
        dateInput: { month: "numeric", year: "numeric", day: "numeric" }
    },
    display: {
        dateInput: SMP_FORMATS[SMP_LOCALE_EN_US],
        monthYearLabel: `${smpMonth}${smpSep}${smpYear}`,
        dateA11yLabel: SMP_FORMATS[SMP_LOCALE_EN_US],
        monthYearA11yLabel: `${smpMonth}${smpSep}${smpYear}`
    }
};
class SmpMatDateLocale extends NativeDateAdapter {
    constructor() {
        super(...arguments);
        this.display = SMP_DATE_FORMATS_EN_GB.display;
    }
    get currentLocale() {
        return this.locale;
    }
    format(date, _displayFormat_) {
        const day = date.getDate();
        const month = date.getMonth() + 1;
        const year = date.getFullYear();
        switch (this.display.dateInput) {
            case SMP_DATE_FORMATS_IT.display.dateInput:
                return this._addLeadingZeroes(day) + smpSep + this._addLeadingZeroes(month) + smpSep + year;
            case SMP_DATE_FORMATS_EN_GB.display.dateInput:
                return this._addLeadingZeroes(day) + smpSep + this._addLeadingZeroes(month) + smpSep + year;
            case SMP_DATE_FORMATS_EN_US.display.dateInput:
                return month + smpSep + day + smpSep + year;
            default:
                let formattedDate = "";
                try {
                    formattedDate = date.toLocaleDateString(SMP_LOCALE_EN_GB);
                }
                catch (e) {
                    console.warn("Caught error while printing ", e);
                    formattedDate = date.toDateString();
                }
                return formattedDate;
        }
    }
    parse(value) {
        if (typeof value === typeof "" && value.length > 0) {
            const str = value.split(smpSep);
            if (str.length < 3) {
                return new Date("smp");
            }
            if (str[2].length < 4) {
                str[2] = smpCentury + str[2];
            }
            if (str[2].length !== 4) {
                return new Date("smp");
            }
            if (includes([SMP_DATE_FORMATS_IT.display.dateInput, SMP_DATE_FORMATS_EN_GB.display.dateInput], this.display.dateInput)) {
                return new Date(+str[2], +str[1] - 1, +str[0]);
            }
            else if (this.display.dateInput === SMP_DATE_FORMATS_EN_US.display.dateInput) {
                return new Date(+str[2], +str[0] - 1, +str[1]);
            }
        }
        else {
            console.warn("Date input format not valid." +
                " Be sure to use SMP_DATE_FORMATS" +
                " or extend this class with your own 'parser' and format 'methods'");
            return null;
        }
    }
    setLocale(locale) {
        switch (locale) {
            case SMP_LOCALE_IT_IT:
                this.display = SMP_DATE_FORMATS_IT.display;
                break;
            case SMP_LOCALE_EN_GB:
                this.display = SMP_DATE_FORMATS_EN_GB.display;
                break;
            case SMP_LOCALE_EN_US:
                this.display = SMP_DATE_FORMATS_EN_US.display;
                break;
            default:
                this.display = SMP_DATE_FORMATS_EN_GB.display;
                break;
        }
        super.setLocale(locale);
    }
    _addLeadingZeroes(n) {
        return `0${n}`.slice(-2);
    }
}
SmpMatDateLocale.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpMatDateLocale, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
SmpMatDateLocale.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpMatDateLocale });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpMatDateLocale, decorators: [{
            type: Injectable
        }] });

class SmpDomService {
    constructor(_componentFactoryResolver, _appRef, _injector) {
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this._refs = {};
    }
    appendComp(component, key, target = "body", injector = this._injector, hook = timer(0)) {
        const componentRef = this._componentFactoryResolver
            .resolveComponentFactory(component)
            .create(injector);
        this._appRef.attachView(componentRef.hostView);
        const domElem = componentRef.hostView
            .rootNodes[0];
        if (!!key) {
            !!this._refs[key] && console.warn("A ref with this key already exists and will be overwritten");
            this._refs[key] = componentRef;
        }
        else {
            console.warn("Component appended, but key wasn't provided. It won't be possible to remove it from the DOM automagically");
        }
        hook
            .pipe(first())
            .subscribe(() => {
            const targetEl = (typeof target === typeof ""
                ? document.querySelector(target)
                : target instanceof ElementRef ? target.nativeElement : target) || document.body;
            targetEl.appendChild(domElem);
        });
        return componentRef;
    }
    appendComps(compsData, injector, hook) {
        compsData.forEach((compData) => this.appendComp(compData.comp, compData.key, compData.target, injector, hook));
    }
    createInjector(token, value, viewContainerRef) {
        const providers = [
            { provide: token, useValue: value }
        ];
        return Injector.create({
            parent: viewContainerRef ? viewContainerRef.injector : this._injector,
            providers
        });
    }
    removeComp(key) {
        if (!!this._refs[key]) {
            const componentRef = this._refs[key];
            this._appRef.detachView(componentRef.hostView);
            componentRef.destroy();
            return !0;
        }
        else {
            console.warn(`No ref found with key ${key}`);
            return !1;
        }
    }
}
SmpDomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpDomService, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.ApplicationRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
SmpDomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpDomService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpDomService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.ApplicationRef }, { type: i0.Injector }]; } });

class SmpCoreUtilsModule {
    static forRoot() {
        return {
            ngModule: SmpCoreUtilsModule,
            providers: [
                SmpDomService
            ]
        };
    }
}
SmpCoreUtilsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpCoreUtilsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SmpCoreUtilsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpCoreUtilsModule });
SmpCoreUtilsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpCoreUtilsModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpCoreUtilsModule, decorators: [{
            type: NgModule,
            args: [{}]
        }] });

export { SMP_DATE_FORMATS_EN_GB, SMP_DATE_FORMATS_EN_US, SMP_DATE_FORMATS_IT, SMP_FORMATS, SMP_LOCALE_EN_GB, SMP_LOCALE_EN_US, SMP_LOCALE_IT_IT, SmpCoreUtilsModule, SmpDomService, SmpMatDateLocale };
//# sourceMappingURL=smp-core-utils.mjs.map
