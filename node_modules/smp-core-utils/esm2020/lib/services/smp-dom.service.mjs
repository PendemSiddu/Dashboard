import { ElementRef, Injectable } from "@angular/core";
import { Injector } from "@angular/core";
import { first, timer } from "rxjs";
import * as i0 from "@angular/core";
export class SmpDomService {
    constructor(_componentFactoryResolver, _appRef, _injector) {
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this._refs = {};
    }
    appendComp(component, key, target = "body", injector = this._injector, hook = timer(0)) {
        const componentRef = this._componentFactoryResolver
            .resolveComponentFactory(component)
            .create(injector);
        this._appRef.attachView(componentRef.hostView);
        const domElem = componentRef.hostView
            .rootNodes[0];
        if (!!key) {
            !!this._refs[key] && console.warn("A ref with this key already exists and will be overwritten");
            this._refs[key] = componentRef;
        }
        else {
            console.warn("Component appended, but key wasn't provided. It won't be possible to remove it from the DOM automagically");
        }
        hook
            .pipe(first())
            .subscribe(() => {
            const targetEl = (typeof target === typeof ""
                ? document.querySelector(target)
                : target instanceof ElementRef ? target.nativeElement : target) || document.body;
            targetEl.appendChild(domElem);
        });
        return componentRef;
    }
    appendComps(compsData, injector, hook) {
        compsData.forEach((compData) => this.appendComp(compData.comp, compData.key, compData.target, injector, hook));
    }
    createInjector(token, value, viewContainerRef) {
        const providers = [
            { provide: token, useValue: value }
        ];
        return Injector.create({
            parent: viewContainerRef ? viewContainerRef.injector : this._injector,
            providers
        });
    }
    removeComp(key) {
        if (!!this._refs[key]) {
            const componentRef = this._refs[key];
            this._appRef.detachView(componentRef.hostView);
            componentRef.destroy();
            return !0;
        }
        else {
            console.warn(`No ref found with key ${key}`);
            return !1;
        }
    }
}
SmpDomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpDomService, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.ApplicationRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
SmpDomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpDomService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: SmpDomService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.ApplicationRef }, { type: i0.Injector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21wLWRvbS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc21wLWNvcmUtdXRpbHMvc3JjL2xpYi9zZXJ2aWNlcy9zbXAtZG9tLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVILFVBQVUsRUFDVixVQUFVLEVBS2IsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUt2QyxPQUFPLEVBQUMsS0FBSyxFQUFjLEtBQUssRUFBQyxNQUFNLE1BQU0sQ0FBQzs7QUFHOUMsTUFBTSxPQUFPLGFBQWE7SUFJdEIsWUFBb0IseUJBQW1ELEVBQ25ELE9BQXVCLEVBQ3ZCLFNBQW1CO1FBRm5CLDhCQUF5QixHQUF6Qix5QkFBeUIsQ0FBMEI7UUFDbkQsWUFBTyxHQUFQLE9BQU8sQ0FBZ0I7UUFDdkIsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQUovQixVQUFLLEdBQWdCLEVBQUUsQ0FBQztJQUtoQyxDQUFDO0lBVUQsVUFBVSxDQUFVLFNBQWtCLEVBQ2xCLEdBQVksRUFDWixTQUE0QyxNQUFNLEVBQ2xELFdBQXFCLElBQUksQ0FBQyxTQUFTLEVBQ25DLE9BQWtDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFFMUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLHlCQUF5QjthQUM5Qyx1QkFBdUIsQ0FBQyxTQUFvQixDQUFDO2FBQzdDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUd0QixJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7UUFHL0MsTUFBTSxPQUFPLEdBQUksWUFBWSxDQUFDLFFBQWlDO2FBQzFELFNBQVMsQ0FBQyxDQUFDLENBQWdCLENBQUM7UUFFakMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFO1lBQ1AsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyw0REFBNEQsQ0FBQyxDQUFDO1lBQ2hHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsWUFBWSxDQUFDO1NBQ2xDO2FBQ0k7WUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLDJHQUEyRyxDQUFDLENBQUM7U0FDN0g7UUFFRCxJQUFJO2FBQ0MsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ2IsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUVoQixNQUFNLFFBQVEsR0FBRyxDQUFDLE9BQU8sTUFBTSxLQUFLLE9BQU8sRUFBRTtnQkFDekMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBZ0IsQ0FBQztnQkFDMUMsQ0FBQyxDQUFDLE1BQU0sWUFBWSxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUM7WUFDckYsUUFBUSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNsQyxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sWUFBK0IsQ0FBQztJQUMzQyxDQUFDO0lBRUQsV0FBVyxDQUFDLFNBQXdCLEVBQUUsUUFBbUIsRUFBRSxJQUFnQztRQUN2RixTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ25ILENBQUM7SUFFRCxjQUFjLENBQVUsS0FBd0IsRUFBRSxLQUFRLEVBQUUsZ0JBQW1DO1FBQzNGLE1BQU0sU0FBUyxHQUFxQjtZQUNoQyxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBQztTQUNwQyxDQUFDO1FBRUYsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDO1lBQ25CLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUztZQUNyRSxTQUFTO1NBQ1osQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELFVBQVUsQ0FBQyxHQUFXO1FBQ2xCLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDbkIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDL0MsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRXZCLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDYjthQUNJO1lBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyx5QkFBeUIsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUU3QyxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ2I7SUFDTCxDQUFDOzswR0FuRlEsYUFBYTs4R0FBYixhQUFhOzJGQUFiLGFBQWE7a0JBRHpCLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudFJlZixcbiAgICBFbGVtZW50UmVmLFxuICAgIEluamVjdGFibGUsXG4gICAgSW5qZWN0aW9uVG9rZW4sXG4gICAgU3RhdGljUHJvdmlkZXIsXG4gICAgVHlwZSxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQge0NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7QXBwbGljYXRpb25SZWZ9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQge0luamVjdG9yfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHtFbWJlZGRlZFZpZXdSZWZ9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG4vL1xuaW1wb3J0IHtTbXBDb21wUmVmcywgU21wQ29tcERhdGF9IGZyb20gXCIuLi9tb2RlbHMvcHVibGljXCI7XG4vL1xuaW1wb3J0IHtmaXJzdCwgT2JzZXJ2YWJsZSwgdGltZXJ9IGZyb20gXCJyeGpzXCI7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTbXBEb21TZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX3JlZnM6IFNtcENvbXBSZWZzID0ge307XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgICBwcml2YXRlIF9hcHBSZWY6IEFwcGxpY2F0aW9uUmVmLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3Rvcikge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXBvbmVudDogdGhlIGNsYXNzIGNvbXBvbmVudCB0byBkeW5hbWljYWxseSBhcHBlbmRcbiAgICAgKiBAcGFyYW0ga2V5OiBhIGtleSB1c2VkIHRvIHJldHJpZXZlIHRoZSBjb21wb25lbnQgYWZ0ZXIgaXQncyBiZWVuIGFwcGVuZGVkIChhbGxvd3MgcmVtb3ZhbClcbiAgICAgKiBAcGFyYW0gdGFyZ2V0OiB0aGUgZG9tIHNlbGVjdG9yL2VsZW1lbnQvcmVmIHdoZXJlIHRoZSBuZXcgY29tcCB3aWxsIGJlIGFwcGVuZGVkXG4gICAgICogQHBhcmFtIGluamVjdG9yOiBvcHRpb25hbCBpbmplY3RvciB0byBvdmVycmlkZSB0aGUgY29tcG9uZW50IHBhcmFtc1xuICAgICAqIEBwYXJhbSBob29rOiBvcHRpb25hbCBob29rIHRvIGRlbGF5IHRoZSBhcHBlbmQgYWN0aW9uLiBDYW4gYmUgYW55IG9ic2VydmFibGUuXG4gICAgICovXG4gICAgYXBwZW5kQ29tcDxUID0gYW55Pihjb21wb25lbnQ6IFR5cGU8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk/OiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHN0cmluZyB8IEhUTUxFbGVtZW50IHwgRWxlbWVudFJlZiA9IFwiYm9keVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3I6IEluamVjdG9yID0gdGhpcy5faW5qZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBob29rOiBPYnNlcnZhYmxlPHZvaWQgfCBudW1iZXI+ID0gdGltZXIoMCkpOiBDb21wb25lbnRSZWY8VD4ge1xuICAgICAgICAvLyAxLiBDcmVhdGUgYSBjb21wb25lbnQgcmVmZXJlbmNlIGZyb20gdGhlIGNvbXBvbmVudFxuICAgICAgICBjb25zdCBjb21wb25lbnRSZWYgPSB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnQgYXMgVHlwZTxUPilcbiAgICAgICAgICAgIC5jcmVhdGUoaW5qZWN0b3IpO1xuXG4gICAgICAgIC8vIDIuIEF0dGFjaCBjb21wb25lbnQgdG8gdGhlIGFwcFJlZiBzbyB0aGF0IGl0J3MgaW5zaWRlIHRoZSBuZyBjb21wb25lbnQgdHJlZVxuICAgICAgICB0aGlzLl9hcHBSZWYuYXR0YWNoVmlldyhjb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuXG4gICAgICAgIC8vIDMuIEdldCBET00gZWxlbWVudCBmcm9tIGNvbXBvbmVudFxuICAgICAgICBjb25zdCBkb21FbGVtID0gKGNvbXBvbmVudFJlZi5ob3N0VmlldyBhcyBFbWJlZGRlZFZpZXdSZWY8YW55PilcbiAgICAgICAgICAgIC5yb290Tm9kZXNbMF0gYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCEha2V5KSB7XG4gICAgICAgICAgICAhIXRoaXMuX3JlZnNba2V5XSAmJiBjb25zb2xlLndhcm4oXCJBIHJlZiB3aXRoIHRoaXMga2V5IGFscmVhZHkgZXhpc3RzIGFuZCB3aWxsIGJlIG92ZXJ3cml0dGVuXCIpO1xuICAgICAgICAgICAgdGhpcy5fcmVmc1trZXldID0gY29tcG9uZW50UmVmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ29tcG9uZW50IGFwcGVuZGVkLCBidXQga2V5IHdhc24ndCBwcm92aWRlZC4gSXQgd29uJ3QgYmUgcG9zc2libGUgdG8gcmVtb3ZlIGl0IGZyb20gdGhlIERPTSBhdXRvbWFnaWNhbGx5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaG9va1xuICAgICAgICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gNC4gQXBwZW5kIERPTSBlbGVtZW50IHRvIHRoZSBib2R5XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRFbCA9ICh0eXBlb2YgdGFyZ2V0ID09PSB0eXBlb2YgXCJcIlxuICAgICAgICAgICAgICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQgYXMgc3RyaW5nKVxuICAgICAgICAgICAgICAgIDogdGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudFJlZiA/IHRhcmdldC5uYXRpdmVFbGVtZW50IDogdGFyZ2V0KSB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgdGFyZ2V0RWwuYXBwZW5kQ2hpbGQoZG9tRWxlbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWYgYXMgQ29tcG9uZW50UmVmPFQ+O1xuICAgIH1cblxuICAgIGFwcGVuZENvbXBzKGNvbXBzRGF0YTogU21wQ29tcERhdGFbXSwgaW5qZWN0b3I/OiBJbmplY3RvciwgaG9vaz86IE9ic2VydmFibGU8dm9pZCB8IG51bWJlcj4pOiB2b2lkIHtcbiAgICAgICAgY29tcHNEYXRhLmZvckVhY2goKGNvbXBEYXRhKSA9PiB0aGlzLmFwcGVuZENvbXAoY29tcERhdGEuY29tcCwgY29tcERhdGEua2V5LCBjb21wRGF0YS50YXJnZXQsIGluamVjdG9yLCBob29rKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlSW5qZWN0b3I8VCA9IGFueT4odG9rZW46IEluamVjdGlvblRva2VuPFQ+LCB2YWx1ZTogVCwgdmlld0NvbnRhaW5lclJlZj86IFZpZXdDb250YWluZXJSZWYpOiBJbmplY3RvciB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyczogU3RhdGljUHJvdmlkZXJbXSA9IFtcbiAgICAgICAgICAgIHtwcm92aWRlOiB0b2tlbiwgdXNlVmFsdWU6IHZhbHVlfVxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBJbmplY3Rvci5jcmVhdGUoe1xuICAgICAgICAgICAgcGFyZW50OiB2aWV3Q29udGFpbmVyUmVmID8gdmlld0NvbnRhaW5lclJlZi5pbmplY3RvciA6IHRoaXMuX2luamVjdG9yLFxuICAgICAgICAgICAgcHJvdmlkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbW92ZUNvbXAoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCEhdGhpcy5fcmVmc1trZXldKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZWYgPSB0aGlzLl9yZWZzW2tleV07XG4gICAgICAgICAgICB0aGlzLl9hcHBSZWYuZGV0YWNoVmlldyhjb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgICAgICAgICAgY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBObyByZWYgZm91bmQgd2l0aCBrZXkgJHtrZXl9YCk7XG5cbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIl19